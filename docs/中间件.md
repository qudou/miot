# 中间件

与用户端类似，中间件也是一个 `js` 文件，它的名称是已注册好的一个 `uuid`。与用户端不同的是，中间件不是必须的。下面是一个中间件的代码框架，其中顶层命名空间与文件名是一致的。组件 `Index` 是会第一个被实例化的入口组件。

```js
// 01-01
xmlplus("c4af113c-e299-4b5c-a376-27dfc6665266", (xp, $_) => {

$_().imports({
    Index: {
        xml: "<i:Middle id='middle' xmlns:i='//miot/proxy'>\
                <!--这里是其它内容-->
              </i:Middle>"
    }
});
```

从上面的示例可以看出，中间件的入口组件 `Index` 的视图项必须以命名空间 `//miot/proxy` 中的组件 `Middle` 作为容器。

## 数据的流入

中间件的数据只能来自用户端，也就是说，中间件的数据流来源是单向的。

```js
// 01-01
Index: {
    xml: "<i:Middle id='middle' xmlns:i='//miot/proxy'>\
            <NodeA id='nodeA'/>\
            <NodeB id='nodeB'/>\
          </i:Middle>",
    fun: function (sys, items, opts) {
        sys.nodeA.on("enter", (e, payload) => {
            console.log(payload);
        });
    }
}
```

上面的示例演示了中间件如何接收来自用户端的数据流。通过侦听来自 `Middle` 的第一个子节点的 `enter` 事件，就可以接收来自用户端的数据流。上面示例只有 `nodeA` 才能有效侦听 `enter` 事件，哪怕 `nodeB` 也注册了 `enter` 侦听器。

中间件的数据流是一个 `PlainObject`，其中包含的一个 `body` 数据项即用户端发送过来的数据体。用户端说明文档 `用户端.md` 中有一个数据发送语句如下：

```
this.trigger("publish", ["payload", {vol: 88}]);
```

那么，在相应的中间件中，就可以通过数据流中的 `body` 数据项来得到如上的数据项 `{vol: 88}`。

## 数据的流出

从中间件出来的数据流有两个去向，一个是用户端，另一个是配件端。如果目的的是用户端，那么需要派发 `to-user` 事件；下面的示例中，当 `node` 节点接收到数据流后，给数据流的数据 `body` 附加了一数据项 `vol`，然后将数据流派发给用户端。

```js
// 01-01
Index: {
    xml: "<i:Middle id='middle' xmlns:i='//miot/proxy'>\
            <Node id='node'/>\
          </i:Middle>",
    fun: function (sys, items, opts) {
        sys.node.on("enter", (e, payload) => {
            payload.body.vol = 88;
            this.trigger("to-user", payload);
        });
    }
}
```

如果是目的的是配件端，则需要派发 `to-part` 事件。该事件的使用方式与 `to-user` 除了名称和目的不同外，其它方面的内容完全是一致的。

## 数据流的结构

数据流是一个 `PlainObject` 类型的对象，它包含三个字段：

```
link: String 局域网关标识符
pid:  String 局域网配件标识符
body: PlainObject 数据体
```

其中，`link` 和 `pid` 决定了数据流的去向。数据体则是数据流所携带的数据对象。在设计中间件的时候，是不可以修改 `link` 和 `pid` 的，否则，数据流将不可能到达目的的。然而，`body` 字段是允许进行修改的。