# 用户端模板

用户端模板是一个 `js` 文件，它的名称是已注册好的一个 `uuid`。下面是一个用户端模板的代码框架，其中顶层命名空间与文件名是一致的。组件 `Index` 是会第一个被实例化的入口组件。最后的 `if` 语句是为了满足 `require.js` 规范而添加的。

```js
// 01-01
xmlplus("26cfb15c-1bb5-11e8-accf-0ed5f89f718b", (xp, $_) => {

$_().imports({
    Index: {
        // 入口
    }
});

if ( typeof define === "function" ) {
    define( "xmlplus", [], function () { return xmlplus; } );
}
```

## 初始化

作为第一个被实例化的入口组件，当 `Index` 的函数项被执行时，函数的参数 `opts` 包含了两个初始化数据：`name` 和 `data`。其中，`name` 是该应用的名称标识，`data` 是初始化数据。

```js
// 01-02
Index: {
    fun: function (sys, items, opts) {
        // 含 name 和 data 两个选项
        console.log(opts);
    }
}
```

`name` 可以作为标题名置顶。当然，也可以忽略它。`data` 是一个 `PlainObject` 类型的数据，不同的应用可以有不同的 `data` 内容。


## 数据的同步

上面讲到的 `data` 不是一成不变的。当中间件或者配件端的对等的 `data` 发生变化时，用户端的 `data` 也会相应地得到更新。要获取更新的数据以保持数据同步，需要侦听 `data-change` 消息。

```js
// 01-03
Index: {
    fun: function (sys, items, opts) {
        this.watch("data-change", (e, data) => {
            console.log(data);
        });
    }
}
```

## 与中间件或者配件间的数据交互

向中间件或者配件提交数据，不需要明确指出具体的端，这是中间件或者配件的工作。通过触发 `publish` 事件即完成数据的提交。

```js
// 01-04
Index: {
    xml: "<button id='index'>submit</button>",
    fun: function (sys, items, opts) {
        this.on("click", () => {
            this.trigger("publish", ["payload", {vol: 88}]);
        });
    }
}
```

如上述代码所描述的，提交的数据是一个数组，数组首位是一个用于标识数据主题的字符串。数组的次位是一个 `PlainObject` 类型的对象。

接收中间件或者配件端的数据，不需要特别的方式，只需建立一个侦听目标主题的消息侦听器即可。

```js
// 01-05
Index: {
    xml: "<button id='index'>submit</button>",
    fun: function (sys, items, opts) {
        this.watch("payload", (e, data) => {
            console.log(data);
        });
    }
}
```

由于用户端与中间件以及配件间的数据交互是建立在 `MQTT` 协议的 `QoS 1` 机制上的，所以在一些应用场合应该注意消息的重入问题。

需要注意的是，消息 `data-change` 由系统用于基础数据的同步，所以在设计通信协议时应该避免使用该字符串作为消息关键字。具体请参考本章的第二节所述内容。
